/*
 * 		    GNU GENERAL PUBLIC LICENSE
 * 		       Version 2, June 1991
 * 
 *  Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 * 
 * 			    Preamble
 * 
 *   The licenses for most software are designed to take away your
 * freedom to share and change it.  By contrast, the GNU General Public
 * License is intended to guarantee your freedom to share and change free
 * software--to make sure the software is free for all its users.  This
 * General Public License applies to most of the Free Software
 * Foundation's software and to any other program whose authors commit to
 * using it.  (Some other Free Software Foundation software is covered by
 * the GNU Lesser General Public License instead.)  You can apply it to
 * your programs, too.
 * 
 *   When we speak of free software, we are referring to freedom, not
 * price.  Our General Public Licenses are designed to make sure that you
 * have the freedom to distribute copies of free software (and charge for
 * this service if you wish), that you receive source code or can get it
 * if you want it, that you can change the software or use pieces of it
 * in new free programs; and that you know you can do these things.
 * 
 *   To protect your rights, we need to make restrictions that forbid
 * anyone to deny you these rights or to ask you to surrender the rights.
 * These restrictions translate to certain responsibilities for you if you
 * distribute copies of the software, or if you modify it.
 * 
 *   For example, if you distribute copies of such a program, whether
 * gratis or for a fee, you must give the recipients all the rights that
 * you have.  You must make sure that they, too, receive or can get the
 * source code.  And you must show them these terms so they know their
 * rights.
 * 
 *   We protect your rights with two steps: (1) copyright the software, and
 * (2) offer you this license which gives you legal permission to copy,
 * distribute and/or modify the software.
 * 
 *   Also, for each author's protection and ours, we want to make certain
 * that everyone understands that there is no warranty for this free
 * software.  If the software is modified by someone else and passed on, we
 * want its recipients to know that what they have is not the original, so
 * that any problems introduced by others will not reflect on the original
 * authors' reputations.
 * 
 *   Finally, any free program is threatened constantly by software
 * patents.  We wish to avoid the danger that redistributors of a free
 * program will individually obtain patent licenses, in effect making the
 * program proprietary.  To prevent this, we have made it clear that any
 * patent must be licensed for everyone's free use or not licensed at all.
 * 
 *   The precise terms and conditions for copying, distribution and
 * modification follow.
 * 
 * 		    GNU GENERAL PUBLIC LICENSE
 *    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 * 
 *   0. This License applies to any program or other work which contains
 * a notice placed by the copyright holder saying it may be distributed
 * under the terms of this General Public License.  The "Program", below,
 * refers to any such program or work, and a "work based on the Program"
 * means either the Program or any derivative work under copyright law:
 * that is to say, a work containing the Program or a portion of it,
 * either verbatim or with modifications and/or translated into another
 * language.  (Hereinafter, translation is included without limitation in
 * the term "modification".)  Each licensee is addressed as "you".
 * 
 * Activities other than copying, distribution and modification are not
 * covered by this License; they are outside its scope.  The act of
 * running the Program is not restricted, and the output from the Program
 * is covered only if its contents constitute a work based on the
 * Program (independent of having been made by running the Program).
 * Whether that is true depends on what the Program does.
 * 
 *   1. You may copy and distribute verbatim copies of the Program's
 * source code as you receive it, in any medium, provided that you
 * conspicuously and appropriately publish on each copy an appropriate
 * copyright notice and disclaimer of warranty; keep intact all the
 * notices that refer to this License and to the absence of any warranty;
 * and give any other recipients of the Program a copy of this License
 * along with the Program.
 * 
 * You may charge a fee for the physical act of transferring a copy, and
 * you may at your option offer warranty protection in exchange for a fee.
 * 
 *   2. You may modify your copy or copies of the Program or any portion
 * of it, thus forming a work based on the Program, and copy and
 * distribute such modifications or work under the terms of Section 1
 * above, provided that you also meet all of these conditions:
 * 
 *     a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 * 
 *     b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 * 
 *     c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 * 
 * These requirements apply to the modified work as a whole.  If
 * identifiable sections of that work are not derived from the Program,
 * and can be reasonably considered independent and separate works in
 * themselves, then this License, and its terms, do not apply to those
 * sections when you distribute them as separate works.  But when you
 * distribute the same sections as part of a whole which is a work based
 * on the Program, the distribution of the whole must be on the terms of
 * this License, whose permissions for other licensees extend to the
 * entire whole, and thus to each and every part regardless of who wrote it.
 * 
 * Thus, it is not the intent of this section to claim rights or contest
 * your rights to work written entirely by you; rather, the intent is to
 * exercise the right to control the distribution of derivative or
 * collective works based on the Program.
 * 
 * In addition, mere aggregation of another work not based on the Program
 * with the Program (or with a work based on the Program) on a volume of
 * a storage or distribution medium does not bring the other work under
 * the scope of this License.
 * 
 *   3. You may copy and distribute the Program (or a work based on it,
 * under Section 2) in object code or executable form under the terms of
 * Sections 1 and 2 above provided that you also do one of the following:
 * 
 *     a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 * 
 *     b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 * 
 *     c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 * 
 * The source code for a work means the preferred form of the work for
 * making modifications to it.  For an executable work, complete source
 * code means all the source code for all modules it contains, plus any
 * associated interface definition files, plus the scripts used to
 * control compilation and installation of the executable.  However, as a
 * special exception, the source code distributed need not include
 * anything that is normally distributed (in either source or binary
 * form) with the major components (compiler, kernel, and so on) of the
 * operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 * 
 * If distribution of executable or object code is made by offering
 * access to copy from a designated place, then offering equivalent
 * access to copy the source code from the same place counts as
 * distribution of the source code, even though third parties are not
 * compelled to copy the source along with the object code.
 * 
 *   4. You may not copy, modify, sublicense, or distribute the Program
 * except as expressly provided under this License.  Any attempt
 * otherwise to copy, modify, sublicense or distribute the Program is
 * void, and will automatically terminate your rights under this License.
 * However, parties who have received copies, or rights, from you under
 * this License will not have their licenses terminated so long as such
 * parties remain in full compliance.
 * 
 *   5. You are not required to accept this License, since you have not
 * signed it.  However, nothing else grants you permission to modify or
 * distribute the Program or its derivative works.  These actions are
 * prohibited by law if you do not accept this License.  Therefore, by
 * modifying or distributing the Program (or any work based on the
 * Program), you indicate your acceptance of this License to do so, and
 * all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 * 
 *   6. Each time you redistribute the Program (or any work based on the
 * Program), the recipient automatically receives a license from the
 * original licensor to copy, distribute or modify the Program subject to
 * these terms and conditions.  You may not impose any further
 * restrictions on the recipients' exercise of the rights granted herein.
 * You are not responsible for enforcing compliance by third parties to
 * this License.
 * 
 *   7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not
 * excuse you from the conditions of this License.  If you cannot
 * distribute so as to satisfy simultaneously your obligations under this
 * License and any other pertinent obligations, then as a consequence you
 * may not distribute the Program at all.  For example, if a patent
 * license would not permit royalty-free redistribution of the Program by
 * all those who receive copies directly or indirectly through you, then
 * the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 * 
 * If any portion of this section is held invalid or unenforceable under
 * any particular circumstance, the balance of the section is intended to
 * apply and the section as a whole is intended to apply in other
 * circumstances.
 * 
 * It is not the purpose of this section to induce you to infringe any
 * patents or other property right claims or to contest validity of any
 * such claims; this section has the sole purpose of protecting the
 * integrity of the free software distribution system, which is
 * implemented by public license practices.  Many people have made
 * generous contributions to the wide range of software distributed
 * through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing
 * to distribute software through any other system and a licensee cannot
 * impose that choice.
 * 
 * This section is intended to make thoroughly clear what is believed to
 * be a consequence of the rest of this License.
 * 
 *   8. If the distribution and/or use of the Program is restricted in
 * certain countries either by patents or by copyrighted interfaces, the
 * original copyright holder who places the Program under this License
 * may add an explicit geographical distribution limitation excluding
 * those countries, so that distribution is permitted only in or among
 * countries not thus excluded.  In such case, this License incorporates
 * the limitation as if written in the body of this License.
 * 
 *   9. The Free Software Foundation may publish revised and/or new versions
 * of the General Public License from time to time.  Such new versions will
 * be similar in spirit to the present version, but may differ in detail to
 * address new problems or concerns.
 * 
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any
 * later version", you have the option of following the terms and conditions
 * either of that version or of any later version published by the Free
 * Software Foundation.  If the Program does not specify a version number of
 * this License, you may choose any version ever published by the Free Software
 * Foundation.
 * 
 *   10. If you wish to incorporate parts of the Program into other free
 * programs whose distribution conditions are different, write to the author
 * to ask for permission.  For software which is copyrighted by the Free
 * Software Foundation, write to the Free Software Foundation; we sometimes
 * make exceptions for this.  Our decision will be guided by the two goals
 * of preserving the free status of all derivatives of our free software and
 * of promoting the sharing and reuse of software generally.
 * 
 * 			    NO WARRANTY
 * 
 *   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 * REPAIR OR CORRECTION.
 * 
 *   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 * 
 * 		     END OF TERMS AND CONDITIONS
 * 		     
 * 		     
 * 
 * 			ADDITIONAL REQUIREMENT
 * 			
 * 1. If PeerfactSim.KOM is used for the evaluation in research publications, 
 * the following should be referenced: 
 * 
 * @techreport{	PWLS07,
 * 	author = {Konstantin Pussep and Matthias Weinert and Nicolas Liebau and Ralf Steinmetz},
 * 	title = {Flexible Framework for NAT Traversal in Peer-to-Peer Applications},
 * 	month = {Nov},
 * 	year = {2007},
 * 	institution = {KOM - Multimedia Communications Lab, Technische Universit{\"a}t Darmstadt},
 * 	address = {Merckstra{\ss}e 25, 64283 Darmstadt, Germany},
 * 	number = {KOM-TR-2007-06},
 * }
 */

package de.tud.kom.nat.im.model;

import java.io.File;
import java.io.IOException;
import java.net.BindException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.channels.DatagramChannel;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.UUID;

import de.tud.kom.nat.comm.ICommFacade;
import de.tud.kom.nat.comm.IMessageHandler;
import de.tud.kom.nat.comm.IMessageProcessor;
import de.tud.kom.nat.comm.msg.IEnvelope;
import de.tud.kom.nat.comm.msg.IMessage;
import de.tud.kom.nat.comm.msg.IPeer;
import de.tud.kom.nat.comm.msg.IPeerID;
import de.tud.kom.nat.comm.msg.Peer;
import de.tud.kom.nat.comm.msg.StayAliveMessage;
import de.tud.kom.nat.comm.msg.UDPPing;
import de.tud.kom.nat.comm.msg.UDPPong;
import de.tud.kom.nat.im.model.files.FileTransfer;
import de.tud.kom.nat.im.model.files.FileTransferManager;
import de.tud.kom.nat.im.model.msg.ChatMessage;
import de.tud.kom.nat.im.model.msg.HostInfo;
import de.tud.kom.nat.im.model.msg.KnownHostsMessage;
import de.tud.kom.nat.im.model.msg.LeaveChatMessage;
import de.tud.kom.nat.nattrav.broker.ConnectionManagerFactory;
import de.tud.kom.nat.nattrav.broker.IApplicationCallback;
import de.tud.kom.nat.nattrav.broker.IConnectionBroker;
import de.tud.kom.nat.nattrav.conn.NatConnector;
import de.tud.kom.nat.util.InetAddressUtils;
import de.tud.kom.nat.util.Logger;
/**
 * The chat model implements all functionality described in the interface
 * <tt>IChatModel</tt>. It provides an abstraction of the chat room.
 * 
 * @author Matthias Weinert
 */
public class ChatModel implements IChatModel, IMessageHandler {

	/** Mapping from addresses to chatpartners. */
	private HashMap<IPeerID, ChatPartner> chatPartners = new HashMap<IPeerID, ChatPartner>();
	
	/** The user interface. */
	private IChatGUI userInterface = null;

	/** The user UDP channel. */
	private DatagramChannel udpChan;

	/** The commFacade. */
	private final ICommFacade commFacade;

	/** Thats me [information about my nick, userid]. */
	private ChatPartner myself = null;

	/** The <tt>FileTransferManager</tt> which deals with filetransfers. */
	private FileTransferManager fileManager = null;
	
	/** The agent which keeps track of who can relay whom. */
	private ChatApplicationCallback relayAgent;
	
	/** The connection manager. */
	private IConnectionBroker connBroker;

	/** The port on which the UDP socket runs. */
	private int port;

	/** The Bootstrap addresses. */
	private Collection<InetSocketAddress> bootstraps;
	
	/** The sender of all stay-alives. */
	private StayAliveSender stayAliveSender;
	
	/** Responsible for determining when guys come online / go offline. */
	private final AvailabilityManager availabilityManager;
	
	/**
	 * Creates a ChatModel using the given port.
	 * 
	 * @param port
	 *            port for udp socket
	 * @throws BindException
	 */
	public ChatModel(int port) throws BindException {
		this(port, null);
	}

	/**
	 * Creates a ChatModel using the given port which sends join messages to all
	 * given bootstrap addresses.
	 * 
	 * @param port
	 *            port for udp socket
	 * @param bootstraps
	 *            bootstrap addresses
	 * @throws BindException
	 */
	public ChatModel(int port, Collection<InetSocketAddress> bootstraps)
			throws BindException {		
		// set "myself"
		this.port = port;
		this.bootstraps = bootstraps;
		createMyself();
		
		// register relay callback
		relayAgent = new ChatApplicationCallback(myself.getPeerID());
		connBroker = ConnectionManagerFactory.createConnectionBroker(relayAgent);
		commFacade = connBroker.getCommFacade();
		relayAgent.setCommFacade(commFacade);
		stayAliveSender = new StayAliveSender(commFacade);
		
		// create channel [this could throw the bindexception]
		createDatagramChannel(port);
		
		// availability
		availabilityManager = new AvailabilityManager(this, udpChan);
		
		// create filemanager and register message types
		registerMessageTypes();
		fileManager = new FileTransferManager(commFacade, port, this);
		
		// enable punching on udp socket
		connBroker.registerUDPChannel(udpChan);
		
		// init message
		Logger.log("INITIALIZED Chat Model: " + getMyself().getPeer());
	}

	private void createMyself() {
		String nickname = "Peer " + new java.util.Random().nextInt(10000);
		InetAddress local = InetAddressUtils.getMostProbableExternalAddress();
//		de.javawi.jstun.test.DiscoveryTest test = new DiscoveryTest(local, "stun.xten.net", 3478);
//		DiscoveryInfo info = null;
//		try {
//			info = test.test();
//		} catch (Exception e) {
//			info = null;
//		}
//		InetSocketAddress localSocketAddr = new InetSocketAddress(info != null ? info.getPublicIP() : local, port);
		InetSocketAddress localSocketAddr = new InetSocketAddress(local, port);
		myself = new ChatPartner(nickname, PeerIDAdapter.getPeerID(UUID.randomUUID()), localSocketAddr, null);
	}

	/**
	 * This method tries to create the datagram channel and bind it to given port.
	 * @param port port for udp socket
	 * @throws BindException
	 */
	private void createDatagramChannel(int port) throws BindException {
		try {
			udpChan = commFacade.openUDPSocket(port);
			
		} catch (BindException e) {
			throw e;
		} catch (IOException e) {
			Logger.logError(e, "Could not initialize chat system! Exiting...");
			throw new IllegalStateException(
					"Error during chat system initialization!");
		}
	}

	/**
	 * Here, all message types for the chatmodel are registered.
	 * 
	 * @param port
	 *            port for udp socket
	 * @throws BindException
	 */
	private void registerMessageTypes() {
		// register
		IMessageProcessor msgProc = commFacade.getMessageProcessor();
		msgProc.registerMessageHandler(ChatMessage.class, this);
		msgProc.registerMessageHandler(KnownHostsMessage.class, this);
		msgProc.registerMessageHandler(UDPPing.class, this);
		msgProc.registerMessageHandler(UDPPong.class, this);
		msgProc.registerMessageHandler(StayAliveMessage.class, this);
		
		// set ping and pong to high priority
		msgProc.setHighPriorityMessageType(UDPPing.class);
		msgProc.setHighPriorityMessageType(UDPPong.class);
	}

	/**
	 * Sends a join to all given addresses.
	 * @param bootstraps addresses
	 */
	private void sendJoin(Collection<InetSocketAddress> addresses) {
		if (addresses == null)
			return;
		for (InetSocketAddress addr : addresses) {
			sendJoin(addr);
		}
	}

	/**
	 * Sends a join to a given address.
	 * @param addr address of a possible chatter
	 */
	public void sendJoin(InetSocketAddress addr) {
		availabilityManager.sendJoin(addr);
	}
	
	/**
	 * Sends a join to a given address, possibly using the ID to establish relayed or punched connections.
	 * @param addr address of a possible chatte, if we already know
	 */
	public void sendJoin(InetSocketAddress addr, IPeerID peerID) {
		if (peerID != null)
			availabilityManager.sendJoin(new Peer(peerID, addr));
		else availabilityManager.sendJoin(addr);
	}

	/**
	 * Sends a join to the given address using the given relay host (this is only possible is we KNOW
	 * the relay host - we do NOT ask the application callback for anything!).
	 * @param address target address
	 * @param relay UDP relay host
	 */
	public void sendJoin(IPeer peer, InetSocketAddress relay) {
		availabilityManager.sendJoin(peer, relay);
	}
	
	public void setUserInterface(IChatGUI obs) {
		this.userInterface = obs;
	}

	public Collection<IChatPartner> getChatPartners() {
		return new ArrayList<IChatPartner>(chatPartners.values());
	}

	public void sendChatMessage(String content) {
		IPeerID myID = getMyself().getPeerID();
		for (ChatPartner cp : chatPartners.values()) {
			ChatMessage cm = new ChatMessage(myID, cp.getPeerID(), content, false);
			try {
				sendMessage(cp, cm);
			} catch (IOException e) {
				Logger.logError(e,
						"Could not send chat message to chat partner: " + cp);
			}
		}
	}

	public void sendChatMessage(IChatPartner chatter, String content) {
		IPeerID myID = getMyself().getPeerID();
		ChatMessage cm = new ChatMessage(myID, chatter.getPeerID(), content, true);
		ChatPartner cp = (ChatPartner) chatter;
		try {
			sendMessage(cp, cm);
		} catch (IOException e) {
			Logger.logError(e, "Could not send chat message to chat partner: "
					+ cp);
		}
	}

	public void onMessageReceived(IEnvelope env) {
		// is ping/pong or stayalive?
		if ((env.getMessage() instanceof UDPPing) || (env.getMessage() instanceof UDPPong)) {
			onReceivedPingPong(env);
			return;
		} else if (env.getMessage() instanceof StayAliveMessage) {
			if (((StayAliveMessage) env.getMessage()).needAnswer()) {
				try {
					IMessage msg = new StayAliveMessage(myself.getPeerID(), env.getSender().getPeerID(), false);
					commFacade.sendUDPMessage((DatagramChannel) env.getChannel(), msg, env.getSender().getAddress());
				} catch (IOException e) {}
			} 
			return;
		}
		
		// is a instant message [of some type, not only chat messages]
		IMessage msg = env.getMessage();
		if (msg.getSenderPeerID().equals(getMyself().getPeerID()))
			return;
		
		// check which type of message
		if (msg instanceof ChatMessage) {
			onReceivedChatMsg(env, msg);
		} else if (msg instanceof KnownHostsMessage) {
			onReceiveKnownHosts(env, msg);
		}
	}

	public synchronized void addChatPartner(ChatPartner partner) {
		// if we know someone with that id => dont add
		if (chatPartners.containsKey(partner.getPeerID()))
			return;
		
		// remove all partners with the same address
		Iterator<ChatPartner> it = chatPartners.values().iterator();
		while (it.hasNext()) {
			ChatPartner cp = it.next();
			if (cp.getPublicAddress().equals(partner.getPublicAddress()))
				it.remove();
		}
		
		// finally... add to the partners list, update gui and distribute known hosts
		chatPartners.put(partner.getPeerID(), partner);
		if (userInterface != null)
			userInterface.onChatterAdded(partner);
		distributeKnownHosts(partner);
	}

	private void onReceiveKnownHosts(IEnvelope env, IMessage msg) {
		KnownHostsMessage khm = (KnownHostsMessage) msg;
		Iterator<HostInfo> it = khm.getHostInfos().iterator();
		while (it.hasNext()) {
			HostInfo info = it.next();
			if (getMyself().getPeerID().equals(info.userID))
				continue;
			if (!chatPartners.containsKey(info.userID)) {
				if (info.relayAddress == null) {
					// just sender as relay address (since he obviously has a connection)
					relayAgent.setRelayHost(info.userID, env.getSender().getAddress());
				} else {
					// set given relay address
					relayAgent.setRelayHost(info.userID, info.relayAddress);
				}
//				sendJoin(info.usedAddress, info.userID);
				// only send join if his id > mine
				if (info.userID.compareTo(getMyself().getPeerID()) >= 1) {
					if (getCallback().testUDPConnectivity(udpChan, info.publicAddress)) {
						sendJoin(info.publicAddress);
					} else sendJoin(info.publicAddress, info.userID);
				}
			}
		}
	}

	public synchronized void removeChatpartner(IChatPartner cp) {
		if (cp != null) {
			Object key = chatPartners.remove(cp.getPeerID());
			if (userInterface != null && key != null)
				userInterface.onChatterRemoved(cp);
		}
	}
	
	private void distributeKnownHosts(ChatPartner cp) {
		// send the new host all chatters we know
		sendAllKnownHosts(cp);
		
		// send this new guy to the rest
		HostInfo hi = new HostInfo();
		hi.publicAddress = cp.getPublicAddress();
		if (cp.getRelayHost() == null)
			hi.relayAddress = new InetSocketAddress(getMyself().getPeer().getAddress().getAddress(), 
				NatConnector.DEFAULT_PORT);
		else hi.relayAddress = cp.getRelayHost();
		hi.userID = cp.getPeerID();
		Collection<HostInfo> hosts = new ArrayList<HostInfo>(1);
		hosts.add(hi);
		for (ChatPartner other: chatPartners.values()) {
			// dont send him info about himself
			if (cp.equals(other))
				continue;
			// send info
			KnownHostsMessage msg = new KnownHostsMessage(getMyself().getPeerID(), cp.getPeerID(), hosts);
			try {
				sendMessage(other, msg);
			} catch (IOException e) {
				Logger.logError(e, "Error sending KnownHostMessage to " + other);
			}
		}
	}

	private void sendAllKnownHosts(ChatPartner cp) {
		KnownHostsMessage khm = new KnownHostsMessage(getMyself().getPeerID(), cp.getPeerID());
		for (ChatPartner known: chatPartners.values()) {
			if (known.getPeerID().equals(cp.getPeerID()))
				continue;
			HostInfo hi = new HostInfo();
			hi.publicAddress = known.getPublicAddress();
			hi.relayAddress = known.getRelayHost();
			if (hi.relayAddress == null) {
				hi.relayAddress = new InetSocketAddress(getMyself().getPeer().getAddress().getAddress(), 
						NatConnector.DEFAULT_PORT);
			}
			hi.userID = known.getPeerID();
			khm.getHostInfos().add(hi);			
		}
		if (khm.getHostInfos().isEmpty())
			return;
		try {
			sendMessage(cp, khm);
		} catch (IOException e) {
			Logger.logError(e, "Could not write a KnownHostMessage to " + cp);
		}
	}

	private void onReceivedPingPong(IEnvelope envelope) {
		if (envelope.getMessage() instanceof UDPPong) {
			Logger.log("RECEIVED a pong from " + envelope.getSender() + "!");
			return;
		}
		
		// its a ping, write back a pong
		DatagramChannel dc = (DatagramChannel) envelope.getChannel();
		InetSocketAddress sender = envelope.getSender().getAddress();
		try {
			getCommFacade().sendUDPMessage(dc, new UDPPong(myself.getPeerID(), 
					envelope.getSender().getPeerID()), sender);
		} catch (IOException e) {
			Logger.logError(e, "Error answering to UDPPing of " + envelope.getSender());
		}
		return;
	}

	private void onReceivedChatMsg(IEnvelope env, IMessage msg) {
		// is buddy on local chatter list?
		ChatMessage cm = (ChatMessage) msg;
		ChatPartner partner = chatPartners.get(cm.getSenderPeerID());
		if (partner == null)
			return;

		// tell observers about it
		if (userInterface != null)
			userInterface.onReceivedChatMessage(partner, cm.isPrivate(), 
					cm.getContent());
	}
	
	public void sendFile(IChatPartner chatter, File file) {
		// just pass to the filemanager
		IPeer peer = chatter.getPeer();
		fileManager.sendFile(peer, file);
	}

	public void sendFile(IChatPartner chatter, File file, InetSocketAddress relayHostAddr) {
		// just pass to the filemanager
		fileManager.sendFile(chatter.getPeer(), file, relayHostAddr);
	}

	/**
	 * Starts the selection process - this means that we start to read 
	 * socket events like read and write data or accept connections.
	 */
	public void startSelectionProcess() {
		commFacade.startSelectionProcess();
		try {
			Thread.sleep(5);
		} catch (InterruptedException e) {}
		sendJoin(bootstraps);
	}

	/**
	 * Returns the commFacade of the chatModel.
	 * @return the ICommFacade
	 */
	public ICommFacade getCommFacade() {
		return commFacade;
	}

	public File onSendFileRequest(IPeer from, String nickname, String filename,
			long size) {
		// get the chatpartner
		if (userInterface == null)
			return null;
		Iterator<ChatPartner> it = chatPartners.values().iterator();
		while (it.hasNext()) {
			// is this the chatpartner who wants to send us a file?
			ChatPartner cp = it.next();
			boolean isOK = true;
			if (!cp.getNickname().equalsIgnoreCase(nickname))
				isOK = false;
//			if (!from.getAddress().equals(cp.getPublicAddress())
//					&& !from.getAddress().equals(cp.getUsedAddr()))
//				isOK = false;
			
			// do we know the right guy? seems so :)
			if (isOK)
				return userInterface.onFileSendRequest(cp, filename, size);
		}

		// we dont know this guy, we dont wonna have his file
		Logger.log("Denied file request because we dont know the requesting peer! [nick+addr]");
		return null;
	}

	public IChatPartner getMyself() {
		return myself;
	}

	public void onStartedFileTransfer(FileTransfer ft) {
		if (userInterface != null)
			userInterface.onStartedFileTransfer(ft);
	}

	public void waitForUI() {
		while (userInterface == null) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				// ignore
			}
		}
	}

	public void shutdown() {
		Iterator<ChatPartner> it = chatPartners.values().iterator();
		while (it.hasNext()) {
			ChatPartner cp = it.next();
			LeaveChatMessage lcm = new LeaveChatMessage(getMyself().getPeerID(), cp.getPeerID());
			try {
				sendMessage(cp, lcm);
			} catch (Exception e) {}
		}
		commFacade.shutdown();
	}

	public IChatPartner getChatPartner(String nick) {
		for (ChatPartner cp: chatPartners.values()) {
			if (cp.getNickname().equalsIgnoreCase(nick))
				return cp;
		}
		return null;
	}

	public IConnectionBroker getConnectionBroker() {
		return connBroker;
	}
	
	private void sendMessage(ChatPartner cp, IMessage msg) throws IOException {
		// channel still open?
		if (!cp.getChannel().isOpen()) {
			Logger.logWarning("Channel to " + cp + " has been closed. Telling UI...");
			removeChatpartner(cp);
			return;
		}
		
		// connected?
		if (cp.getChannel().isConnected()) {
			commFacade.sendUDPMessage(cp.getChannel(), msg);
		} else {
			// if we have a special address we use, take this one; otherwise its public addr
			commFacade.sendUDPMessage(cp.getChannel(), msg, cp.getUsedAddress());
		}
	}

	public IApplicationCallback getCallback() {
		return relayAgent;
	}
	
	void addToStayAlive(ChatPartner cp) {
		stayAliveSender.addStayAlive(cp.getChannel(), cp.getUsedAddress());
	}

	IChatPartner getChatPartner(IPeerID id) {
		return chatPartners.get(id);
	}
	
}
