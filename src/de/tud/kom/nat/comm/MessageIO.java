/*
 * 		    GNU GENERAL PUBLIC LICENSE
 * 		       Version 2, June 1991
 * 
 *  Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 * 
 * 			    Preamble
 * 
 *   The licenses for most software are designed to take away your
 * freedom to share and change it.  By contrast, the GNU General Public
 * License is intended to guarantee your freedom to share and change free
 * software--to make sure the software is free for all its users.  This
 * General Public License applies to most of the Free Software
 * Foundation's software and to any other program whose authors commit to
 * using it.  (Some other Free Software Foundation software is covered by
 * the GNU Lesser General Public License instead.)  You can apply it to
 * your programs, too.
 * 
 *   When we speak of free software, we are referring to freedom, not
 * price.  Our General Public Licenses are designed to make sure that you
 * have the freedom to distribute copies of free software (and charge for
 * this service if you wish), that you receive source code or can get it
 * if you want it, that you can change the software or use pieces of it
 * in new free programs; and that you know you can do these things.
 * 
 *   To protect your rights, we need to make restrictions that forbid
 * anyone to deny you these rights or to ask you to surrender the rights.
 * These restrictions translate to certain responsibilities for you if you
 * distribute copies of the software, or if you modify it.
 * 
 *   For example, if you distribute copies of such a program, whether
 * gratis or for a fee, you must give the recipients all the rights that
 * you have.  You must make sure that they, too, receive or can get the
 * source code.  And you must show them these terms so they know their
 * rights.
 * 
 *   We protect your rights with two steps: (1) copyright the software, and
 * (2) offer you this license which gives you legal permission to copy,
 * distribute and/or modify the software.
 * 
 *   Also, for each author's protection and ours, we want to make certain
 * that everyone understands that there is no warranty for this free
 * software.  If the software is modified by someone else and passed on, we
 * want its recipients to know that what they have is not the original, so
 * that any problems introduced by others will not reflect on the original
 * authors' reputations.
 * 
 *   Finally, any free program is threatened constantly by software
 * patents.  We wish to avoid the danger that redistributors of a free
 * program will individually obtain patent licenses, in effect making the
 * program proprietary.  To prevent this, we have made it clear that any
 * patent must be licensed for everyone's free use or not licensed at all.
 * 
 *   The precise terms and conditions for copying, distribution and
 * modification follow.
 * 
 * 		    GNU GENERAL PUBLIC LICENSE
 *    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 * 
 *   0. This License applies to any program or other work which contains
 * a notice placed by the copyright holder saying it may be distributed
 * under the terms of this General Public License.  The "Program", below,
 * refers to any such program or work, and a "work based on the Program"
 * means either the Program or any derivative work under copyright law:
 * that is to say, a work containing the Program or a portion of it,
 * either verbatim or with modifications and/or translated into another
 * language.  (Hereinafter, translation is included without limitation in
 * the term "modification".)  Each licensee is addressed as "you".
 * 
 * Activities other than copying, distribution and modification are not
 * covered by this License; they are outside its scope.  The act of
 * running the Program is not restricted, and the output from the Program
 * is covered only if its contents constitute a work based on the
 * Program (independent of having been made by running the Program).
 * Whether that is true depends on what the Program does.
 * 
 *   1. You may copy and distribute verbatim copies of the Program's
 * source code as you receive it, in any medium, provided that you
 * conspicuously and appropriately publish on each copy an appropriate
 * copyright notice and disclaimer of warranty; keep intact all the
 * notices that refer to this License and to the absence of any warranty;
 * and give any other recipients of the Program a copy of this License
 * along with the Program.
 * 
 * You may charge a fee for the physical act of transferring a copy, and
 * you may at your option offer warranty protection in exchange for a fee.
 * 
 *   2. You may modify your copy or copies of the Program or any portion
 * of it, thus forming a work based on the Program, and copy and
 * distribute such modifications or work under the terms of Section 1
 * above, provided that you also meet all of these conditions:
 * 
 *     a) You must cause the modified files to carry prominent notices
 *     stating that you changed the files and the date of any change.
 * 
 *     b) You must cause any work that you distribute or publish, that in
 *     whole or in part contains or is derived from the Program or any
 *     part thereof, to be licensed as a whole at no charge to all third
 *     parties under the terms of this License.
 * 
 *     c) If the modified program normally reads commands interactively
 *     when run, you must cause it, when started running for such
 *     interactive use in the most ordinary way, to print or display an
 *     announcement including an appropriate copyright notice and a
 *     notice that there is no warranty (or else, saying that you provide
 *     a warranty) and that users may redistribute the program under
 *     these conditions, and telling the user how to view a copy of this
 *     License.  (Exception: if the Program itself is interactive but
 *     does not normally print such an announcement, your work based on
 *     the Program is not required to print an announcement.)
 * 
 * These requirements apply to the modified work as a whole.  If
 * identifiable sections of that work are not derived from the Program,
 * and can be reasonably considered independent and separate works in
 * themselves, then this License, and its terms, do not apply to those
 * sections when you distribute them as separate works.  But when you
 * distribute the same sections as part of a whole which is a work based
 * on the Program, the distribution of the whole must be on the terms of
 * this License, whose permissions for other licensees extend to the
 * entire whole, and thus to each and every part regardless of who wrote it.
 * 
 * Thus, it is not the intent of this section to claim rights or contest
 * your rights to work written entirely by you; rather, the intent is to
 * exercise the right to control the distribution of derivative or
 * collective works based on the Program.
 * 
 * In addition, mere aggregation of another work not based on the Program
 * with the Program (or with a work based on the Program) on a volume of
 * a storage or distribution medium does not bring the other work under
 * the scope of this License.
 * 
 *   3. You may copy and distribute the Program (or a work based on it,
 * under Section 2) in object code or executable form under the terms of
 * Sections 1 and 2 above provided that you also do one of the following:
 * 
 *     a) Accompany it with the complete corresponding machine-readable
 *     source code, which must be distributed under the terms of Sections
 *     1 and 2 above on a medium customarily used for software interchange; or,
 * 
 *     b) Accompany it with a written offer, valid for at least three
 *     years, to give any third party, for a charge no more than your
 *     cost of physically performing source distribution, a complete
 *     machine-readable copy of the corresponding source code, to be
 *     distributed under the terms of Sections 1 and 2 above on a medium
 *     customarily used for software interchange; or,
 * 
 *     c) Accompany it with the information you received as to the offer
 *     to distribute corresponding source code.  (This alternative is
 *     allowed only for noncommercial distribution and only if you
 *     received the program in object code or executable form with such
 *     an offer, in accord with Subsection b above.)
 * 
 * The source code for a work means the preferred form of the work for
 * making modifications to it.  For an executable work, complete source
 * code means all the source code for all modules it contains, plus any
 * associated interface definition files, plus the scripts used to
 * control compilation and installation of the executable.  However, as a
 * special exception, the source code distributed need not include
 * anything that is normally distributed (in either source or binary
 * form) with the major components (compiler, kernel, and so on) of the
 * operating system on which the executable runs, unless that component
 * itself accompanies the executable.
 * 
 * If distribution of executable or object code is made by offering
 * access to copy from a designated place, then offering equivalent
 * access to copy the source code from the same place counts as
 * distribution of the source code, even though third parties are not
 * compelled to copy the source along with the object code.
 * 
 *   4. You may not copy, modify, sublicense, or distribute the Program
 * except as expressly provided under this License.  Any attempt
 * otherwise to copy, modify, sublicense or distribute the Program is
 * void, and will automatically terminate your rights under this License.
 * However, parties who have received copies, or rights, from you under
 * this License will not have their licenses terminated so long as such
 * parties remain in full compliance.
 * 
 *   5. You are not required to accept this License, since you have not
 * signed it.  However, nothing else grants you permission to modify or
 * distribute the Program or its derivative works.  These actions are
 * prohibited by law if you do not accept this License.  Therefore, by
 * modifying or distributing the Program (or any work based on the
 * Program), you indicate your acceptance of this License to do so, and
 * all its terms and conditions for copying, distributing or modifying
 * the Program or works based on it.
 * 
 *   6. Each time you redistribute the Program (or any work based on the
 * Program), the recipient automatically receives a license from the
 * original licensor to copy, distribute or modify the Program subject to
 * these terms and conditions.  You may not impose any further
 * restrictions on the recipients' exercise of the rights granted herein.
 * You are not responsible for enforcing compliance by third parties to
 * this License.
 * 
 *   7. If, as a consequence of a court judgment or allegation of patent
 * infringement or for any other reason (not limited to patent issues),
 * conditions are imposed on you (whether by court order, agreement or
 * otherwise) that contradict the conditions of this License, they do not
 * excuse you from the conditions of this License.  If you cannot
 * distribute so as to satisfy simultaneously your obligations under this
 * License and any other pertinent obligations, then as a consequence you
 * may not distribute the Program at all.  For example, if a patent
 * license would not permit royalty-free redistribution of the Program by
 * all those who receive copies directly or indirectly through you, then
 * the only way you could satisfy both it and this License would be to
 * refrain entirely from distribution of the Program.
 * 
 * If any portion of this section is held invalid or unenforceable under
 * any particular circumstance, the balance of the section is intended to
 * apply and the section as a whole is intended to apply in other
 * circumstances.
 * 
 * It is not the purpose of this section to induce you to infringe any
 * patents or other property right claims or to contest validity of any
 * such claims; this section has the sole purpose of protecting the
 * integrity of the free software distribution system, which is
 * implemented by public license practices.  Many people have made
 * generous contributions to the wide range of software distributed
 * through that system in reliance on consistent application of that
 * system; it is up to the author/donor to decide if he or she is willing
 * to distribute software through any other system and a licensee cannot
 * impose that choice.
 * 
 * This section is intended to make thoroughly clear what is believed to
 * be a consequence of the rest of this License.
 * 
 *   8. If the distribution and/or use of the Program is restricted in
 * certain countries either by patents or by copyrighted interfaces, the
 * original copyright holder who places the Program under this License
 * may add an explicit geographical distribution limitation excluding
 * those countries, so that distribution is permitted only in or among
 * countries not thus excluded.  In such case, this License incorporates
 * the limitation as if written in the body of this License.
 * 
 *   9. The Free Software Foundation may publish revised and/or new versions
 * of the General Public License from time to time.  Such new versions will
 * be similar in spirit to the present version, but may differ in detail to
 * address new problems or concerns.
 * 
 * Each version is given a distinguishing version number.  If the Program
 * specifies a version number of this License which applies to it and "any
 * later version", you have the option of following the terms and conditions
 * either of that version or of any later version published by the Free
 * Software Foundation.  If the Program does not specify a version number of
 * this License, you may choose any version ever published by the Free Software
 * Foundation.
 * 
 *   10. If you wish to incorporate parts of the Program into other free
 * programs whose distribution conditions are different, write to the author
 * to ask for permission.  For software which is copyrighted by the Free
 * Software Foundation, write to the Free Software Foundation; we sometimes
 * make exceptions for this.  Our decision will be guided by the two goals
 * of preserving the free status of all derivatives of our free software and
 * of promoting the sharing and reuse of software generally.
 * 
 * 			    NO WARRANTY
 * 
 *   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
 * PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
 * REPAIR OR CORRECTION.
 * 
 *   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES.
 * 
 * 		     END OF TERMS AND CONDITIONS
 * 		     
 * 		     
 * 
 * 			ADDITIONAL REQUIREMENT
 * 			
 * 1. If PeerfactSim.KOM is used for the evaluation in research publications, 
 * the following should be referenced: 
 * 
 * @techreport{	PWLS07,
 * 	author = {Konstantin Pussep and Matthias Weinert and Nicolas Liebau and Ralf Steinmetz},
 * 	title = {Flexible Framework for NAT Traversal in Peer-to-Peer Applications},
 * 	month = {Nov},
 * 	year = {2007},
 * 	institution = {KOM - Multimedia Communications Lab, Technische Universit{\"a}t Darmstadt},
 * 	address = {Merckstra{\ss}e 25, 64283 Darmstadt, Germany},
 * 	number = {KOM-TR-2007-06},
 * }
 */

package de.tud.kom.nat.comm;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.PortUnreachableException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ByteChannel;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.util.HashMap;

import de.tud.kom.nat.comm.msg.Envelope;
import de.tud.kom.nat.comm.msg.IEnvelope;
import de.tud.kom.nat.comm.msg.IMessage;
import de.tud.kom.nat.comm.msg.Peer;
import de.tud.kom.nat.comm.msg.StayAliveMessage;
import de.tud.kom.nat.comm.obs.IMessageTracer;
import de.tud.kom.nat.comm.obs.IMessageTracer.MessageState;
import de.tud.kom.nat.comm.serialization.IMessageSerializer;
import de.tud.kom.nat.comm.serialization.SerializerLoader;
import de.tud.kom.nat.comm.util.MappedQueues;
import de.tud.kom.nat.util.Logger;

/**
 * Contains the information how the connection should be limited.
 * 
 * @author Matthias Weinert
 */
class LimitBandwidthInfo {
	
	/**
	 * Maximum amount of incoming bytes per second [if there is more, read is delayed].
	 */
	private int maxInputPerSec = 0;
	
	/**
	 * Maximum amount of outgoing bytes per second [if there is more, write is delayed].
	 */
	private int maxOutputPerSec = 0;
	
	/**
	 * @param bytes amount of allowed incoming bytes per second
	 */
	public void setMaxInputPerSec(int bytes) {
		maxInputPerSec = bytes;
	}
	
	/**
	 * @param bytes amount of allowed outgoing bytes per second
	 */
	public void setMaxOutputPerSec(int bytes) {
		maxOutputPerSec = bytes;
	}

	/**
	 * Returns the maximum amount of incoming bytes per second [if there is more, read is delayed].
	 * @return maximum amount of incoming bytes per second
	 */
	public int getMaxInputPerSec() {
		return maxInputPerSec;
	}

	/**
	 * Returns the maximum amount of outgoing bytes per second [if there is more, write is delayed].
	 * @return maximum amount of outgoing bytes per second
	 */
	public int getMaxOutputPerSec() {
		return maxOutputPerSec;
	}
	
}

/**
 * A item in the sendqueue.
 *
 * @author Matthias Weinert
 */
abstract class QueueItem {
	
	/**
	 * Returns the data which this item wants to send.
	 * @return data of this queue item
	 */
	abstract byte[] getData();
	
	/**
	 * Returns true if all the data have been transferred.
	 * @return true if all the data have been transferred
	 */
	abstract boolean isTransferComplete();
	
	/**
	 * In ordner to support partial transfer of a queue item, the
	 * amount of already transferred bytes must be set here.
	 * 
	 * @param size amount of transferred bytes
	 */
	abstract void increaseTransferred(int size);
	
	/**
	 * Returns the target address. Only used when sending with unconnected UDP channels.
	 * @return target address
	 */
	abstract SocketAddress getTargetAddress();
}

/**
 * Since we can write raw data to a socket, this <tt>RawDataQueueItem</tt>
 * is the concrete item in a queue of a socket which only stored the data
 * and returns them when needed.
 *
 * @author Matthias Weinert
 */
class RawDataQueueItem extends QueueItem {
	
	/** The data which need to be transferred. */
	private byte[] data;

	/** The amount of transferred bytes. */
	private int transferred = 0;
	
	/** Send the data to... (only used for unconnected UDP). */
	private SocketAddress targetAddress = null;
	
	/**
	 * Creates a <tt>RawDataQueueItem</tt> with the given data.
	 * @param data data
	 */
	RawDataQueueItem(byte data[]) {
		this.data = data;
		if (data == null || data.length == 0)
			throw new IllegalStateException("DataQueueItem must not be empty!");
	}
	
	/**
	 * Creates a <tt>RawDataQueueItem</tt> with the given data. All data are sent
	 * to the given address (when using an unconnected <tt>DatagramChannel</tt>).
	 * @param data data
	 * @param sendTo target address
	 */
	RawDataQueueItem(byte data[], SocketAddress sendTo) {
		this.data = data;
		this.targetAddress = sendTo;
		if (data == null || data.length == 0)
			throw new IllegalStateException("DataQueueItem must not be empty!");
	}

	SocketAddress getTargetAddress() {
		return targetAddress;
	}
	
	@Override
	byte[] getData() {
		if (transferred == 0)
			return data;
		byte subdata[] = new byte[data.length-transferred];
		System.arraycopy(data, transferred, subdata, 0, subdata.length);
		return subdata;
	}

	@Override
	public String toString() {
		return "RawDataQueueItem";
	}

	@Override
	void increaseTransferred(int size) {
		transferred += size;
		if (transferred > data.length)
			throw new IllegalStateException("Cannot transfer more data than we have...");
	}

	@Override
	boolean isTransferComplete() {
		return transferred >= data.length;
	}
	
}

/**
 * This queue item is used when we send messages. It is used to serialize
 * the data in the latest moment possible, because we possibly want to support
 * messages which populate some data before they get serialized. Since the call
 * of <tt>getData()</tt> is the last moment where we need the data, it should be
 * created in this method.
 *
 * @author Matthias Weinert
 */
class MessageQueueItem extends RawDataQueueItem {
	
	/** The message. */
	private IMessage msg;

	/** Creates a queue item for the given message. */
	public MessageQueueItem(IMessage msg) {
		super(SerializerLoader.getInstance().serializeMessage(msg, true));
		this.msg = msg;
	}
	
	/** Creates a queue item for the given message. */
	public MessageQueueItem(IMessage msg, SocketAddress sendTo) {
		super(SerializerLoader.getInstance().serializeMessage(msg, true), sendTo);
		this.msg = msg;
	}

	/** Returns the message (debug-purposes). */
	IMessage getMessage() {
		return msg;
	}

	@Override
	public String toString() {
		return "MessageQueueItem: " + msg;
	}
}

/**
 * This object is just an abstraction about data which can be read from a socket. It is used
 * to separate the read-method (which is used more than twice) from others.
 *
 * @author Matthias Weinert
 */
class ReadData {
	
	/**
	 * Creates a readdata object with the given parameters.
	 * @param bb its bytebuffer
	 * @param size size of the read bytes
	 * @param sender sender of the data
	 * @param receiver receiver of the data
	 */
	ReadData(ByteBuffer bb, int size, InetSocketAddress sender, InetSocketAddress receiver) {
		this.byteBuffer = bb;
		this.size = size;
		this.sender = sender;
		this.receiver = receiver;
	}
	
	/** The bytebuffer where we read to. */
	ByteBuffer byteBuffer;
	
	/** Amount of bytes read. */
	int size;
	
	/** The sender of those bytes. */
	InetSocketAddress sender;
	
	/** The receiver of those bytes. */
	InetSocketAddress receiver;
}

/**
 * The <tt>MessageIO</tt> performs the actual reads and writes using several other classes which help 
 * it doing this task. It can be seen as a central component, since here, a lot of functionality comes together
 * to do the real work.<br><br>
 * Two different kind of data can be sent using this class: Raw data (just byte arrays) and messages. The messages
 * are deserialized using the default <tt>ISerializer</tt> which is retrieved by the <tt>SerializedLoader</tt>.
 *
 * @author Matthias Weinert
 */
public class MessageIO implements IIOEventHandler, IBandwidthController {

	/** maximum message size */
	private static final int MAX_MESSAGE_SIZE = 64 * 1024;

	/** buffer manager */
	private final BufferManager bufferManager = new BufferManager();

	/** message processor */
	private final IMessageProcessor msgProc;

	/** send queue */
	private final MappedQueues<SelectableChannel, QueueItem> mappedQueues;
	
	/** event reader */
	private final SocketEventReader eventReader;
	
	/** bandwidth limits */
	private final HashMap<SelectableChannel, LimitBandwidthInfo> bandwidthLimits = new HashMap<SelectableChannel, LimitBandwidthInfo>();

	/** raw readers */
	private final HashMap<SelectableChannel, IRawReader> rawReaders = new HashMap<SelectableChannel, IRawReader>();
	
	/** message tracer */
	private IMessageTracer tracer;
	
	/**
	 * Creates a messageIO object with a given message processor and an event reader.
	 * @param msgProc message processor
	 * @param eventReader event reader
	 */
	public MessageIO(IMessageProcessor msgProc, SocketEventReader eventReader, IMessageTracer tracer) {
		this.msgProc = msgProc;
		this.mappedQueues = new MappedQueues<SelectableChannel, QueueItem>();
		this.eventReader = eventReader;
		this.tracer = tracer;
	}

	/**
	 * This method writes the given message to the queue of the specified channel and sets 
	 * the interested-in-write-flag to <tt>true</tt>.
	 * 
	 * @param msg message
	 * @param chan channel
	 */
	public void writeMessage(IMessage msg, SelectableChannel chan) {
		writeMessage(msg, chan, null);
	}

	public void writeMessage(IMessage msg, SelectableChannel chan, SocketAddress address) {
		// enqueue msg
		mappedQueues.enqueue(chan, new MessageQueueItem(msg, address));
		tracer.setMessageState(msg.getMessageID(), MessageState.QUEUED);
		
		// set event handler to write-interested
		setWriteInterested(chan, true);
	}

	/**
	 * Enqueues the given data to the queue of the channel and sets the interested-in-write-flag to <tt>true</tt>.
	 * @param data data 
	 * @param chan channel
	 */
	public void writeRaw(byte data[], SelectableChannel chan) {
		// enqueue msg
		mappedQueues.enqueue(chan, new RawDataQueueItem(data));
		
		// set event handler to write-interested
		setWriteInterested(chan, true);
	}

	/**
	 * Reads data from the given channel and returns it.
	 * 
	 * @param chan channel to read from
	 * @return the information read in a ReadData object
	 * @throws IOException
	 */
	private ReadData readData(ByteChannel chan) throws IOException {
		// get read buffer
		ByteBuffer bb = bufferManager.getReadBuffer(chan);
		InetSocketAddress sender = null;
		InetSocketAddress receiver = null;
		int read = 0;

		// TODO schöner machen
		try {
			if (chan instanceof DatagramChannel) {
				int posBefore = bb.position();
				sender = (InetSocketAddress) ((DatagramChannel) chan).receive(bb);
				// TODO overwrite sender when connection is relayed?
//				InetSocketAddress viaRelay = ConnectionTargetRequestor.getInstance().getRemoteAddress((SelectableChannel) chan);
//				if (viaRelay != null)
//					sender = viaRelay;
				
				read = bb.position() - posBefore;
				receiver = (InetSocketAddress) ((DatagramChannel) chan)
						.socket().getLocalSocketAddress();
			} else if (chan instanceof SocketChannel) {
				SocketChannel sc = (SocketChannel) chan;
				read = chan.read(bb);
				if (!sc.isOpen() || sc.socket() == null || sc.socket().isClosed()) {
					Logger.logWarning("Reading from socket that is not open!!!");
				}
				// TODO how to react when someone wonna close?
				if (read == -1) {
					sc.close();
					return null;
				}
				sender = (InetSocketAddress) sc.socket().getRemoteSocketAddress();
				// TODO overwrite sender when connection is relayed?
//				InetSocketAddress viaRelay = ConnectionTargetRequestor.getInstance().getRemoteAddress(sc);
//				if (viaRelay != null)
//					sender = viaRelay;
				receiver = (InetSocketAddress) sc.socket().getLocalSocketAddress();
			}
		} catch (PortUnreachableException e) {
			Logger.logWarning("Received PortUnreachableException on " + chan + ", closing channel...");
			try {
				chan.close();
			} catch (IOException e2) {}
			
		} catch (ClosedChannelException e) {
			Logger.logWarning("Channel has been closed by other side: " + chan + ". Closing...");
			try {
				chan.close();
			} catch (IOException e2) {}
			
		} catch (IOException e) {
			Logger.logError(e, "Error reading data from socket: " + chan + ".");
			throw e;
		}
		
		ReadData result = new ReadData(bb, read, sender, receiver);
		return result;
	}
	
	/**
	 * This method is invoked when the bytechannel got new data. It checks whether the available data
	 * is enough to create the message. If thats the case, it does so and passes the message to the 
	 * message processor. If not, it just waits for the next call of this message to do the work; since we
	 * read the same <tt>ByteBuffer</tt> for a channel every time using the <tt>BufferManager</tt>, the delay is
	 * no problem. 
	 * 
	 * @param chan channel to read the message from
	 * @throws IOException
	 */
	public void readMessage(ByteChannel chan) throws IOException {
		// read data
		ReadData readData = readData(chan);
		if (readData == null)
			return;
		
		// delay next write according to maxBytesPerSec
		LimitBandwidthInfo info = bandwidthLimits.get(chan);
		if (info != null && info.getMaxInputPerSec() != -1) {
			// read delay in milliseconds [factor 1000]
			int readDelay = readData.size * 1000 / info.getMaxInputPerSec();
			eventReader.delayNextRead((SelectableChannel) chan, readDelay);
		}
		
		// get messagesize
		ByteBuffer bb = readData.byteBuffer;
		createMessages(chan, readData, bb);

	}

	/**
	 * This method checks whether we have complete messages in the bytebuffer; if thats the case,
	 * it calls <tt>createMessage</tt> that performs the real creation of the message.
	 * @param chan channel to read from
	 * @param readData the read data
	 * @param bb the bytebuffer
	 */
	private void createMessages(ByteChannel chan, ReadData readData, ByteBuffer bb) {
		// try to create messages till there are no complete messages stored
		int size = -1;
		while ((size = getMessageSize(bb)) != -1) {
			// 1. size is higher than buffer capacity
			// 2. we dont have all data
			// 3. we have the data for the next message, read it
			if (bb.capacity() < size) {
				// TODO message not be received in this buffer completely, save data
				// in extended buffer
				throw new UnsupportedOperationException("Not yet supported!");

			} else if (bb.position() + 4 < size) {
				// just wait for more data
				break;

			} else {
				createMessage(chan, readData, bb, size);
			}	
		}
	}

	/**
	 * When this method is invoked, we already check that there is a message in our bytebuffer. Here, we
	 * deserialize the message and pass it to the messageprocessor which passes it to the correct
	 * handler.
	 * 
	 * @param chan the channel where we received the message
	 * @param readData information about the read data
	 * @param bb the bytebuffer
	 * @param size the size of the message
	 */
	private void createMessage(ByteChannel chan, ReadData readData, ByteBuffer bb, int size) {
		// Log messages?
		final boolean LOG_SEND_MSGS = true;
		
		// we have the message, flip and set position to 4
		bb.flip().position(4);
		
		// message received, deserialize
		IMessageSerializer seri = SerializerLoader.getInstance();
		IMessage msg = seri.deserializeMessage(bb, size);
		bb.position(size + 4);
		bb.compact();

		// create envelope
		IEnvelope env = Envelope.createIncomingEnv(msg, new Peer(msg.getSenderPeerID(), readData.sender), chan);
		if (LOG_SEND_MSGS && !(msg instanceof StayAliveMessage))
			Logger.log("[" + readData.receiver + "] RECV " + msg + " from " + readData.sender);
		msgProc.handleMessage(env);
	}

	public void onCanAccept(SelectableChannel channel) {
		throw new UnsupportedOperationException();
	}

	public void onCanRead(SelectableChannel channel) {
		// rawreader registered?
		IRawReader rawReader = rawReaders.get(channel);
		
		// read		
		try {
			if (rawReader != null) {
				readRaw(channel, rawReader);
			} else readMessage((ByteChannel) channel);
		} catch (PortUnreachableException e) {
			Logger.logError(e, "");
			
		} catch (IOException e) {
			Logger.logError(e, "Error reading from channel " + channel);
			if (channel instanceof SocketChannel) {
				// close to prevent endless loops of "has been closed"
				try {
					channel.close();
				} catch (IOException e1) {}
			}
		}
	}

	/**
	 * This method is called if there is a <tt>IRawReader</tt> registered for the given
	 * <tt>channel</tt> and it can read data. Just read it and pass the data to the
	 * <tt>rawReader</tt>.
	 * 
	 * @param channel channel to read from
	 * @param rawReader pass data to this raw reader
	 * @throws IOException
	 */
	private void readRaw(SelectableChannel channel, IRawReader rawReader) throws IOException {
		ReadData rd = readData((ByteChannel) channel);
		if (rd == null)
			return;
		ByteBuffer bb = rd.byteBuffer;
		bb.flip();
		byte data[] = new byte[bb.remaining()];
		bb.get(data);
		bb.compact();
		rawReader.onReadData(channel, data);
	}

	public void onCanWrite(SelectableChannel channel) {
		// we ARE about to write, remove write interested flag
		setWriteInterested(channel, false);
		
		// Write loop till...
		// 1. we dont have anything left to write
		// 2. send buffer of tcp stack is full
		// 3. bandwidth limitation says we must not write
		QueueItem msg = null;
		while ((msg = mappedQueues.peek(channel)) != null) {
			// get data
			byte data[] = msg.getData();
			
			// can we send it due to bandwidth limits?
			if (!isSendAllowed(data.length)) {
				break;
			}
			
			// write data
			if (!writeData(channel, msg, data))
				break;
		}
		
		// if the queue is empty, msg should be null. if its not, try to send later
		if (msg != null) {
			setWriteInterested(channel, true);
		}
	}

	private boolean writeData(SelectableChannel channel, QueueItem item, byte data[]) {
//		 assume that the byte channel ops are available
		ByteChannel bc = (ByteChannel) channel;
		ByteBuffer bb = ByteBuffer.wrap(data);
		try {	
			// write and log
			logWriting(item, channel);
			
			// write
			int written = 0;
			if (item.getTargetAddress() != null) {
				DatagramChannel dc = (DatagramChannel) channel;
				written = dc.send(bb, item.getTargetAddress());
			} else written = bc.write(bb);
			refreshBandwidthLimits(channel, written);
			item.increaseTransferred(written);
			if (!item.isTransferComplete()) {
				// stop writing, set write interested to true
				setWriteInterested(channel, true);
				return false;
			} else {
				// remove it, since we transferred it
				mappedQueues.poll(channel);
			}
			
			// tracer wants to know then messages are sent
			if (item instanceof MessageQueueItem)
				tracer.setMessageState(((MessageQueueItem) item).getMessage().getMessageID(), MessageState.SENT);
			
		} catch (IOException e) {
			Logger.logError(e, "Error sending message of type " + item);
			return false;
		}
		
		// all fine
		return true;
	}
	
	private void logWriting(QueueItem item, SelectableChannel channel) {
		// dont log StayAlives
		if (item instanceof MessageQueueItem) {
			MessageQueueItem msgItem = (MessageQueueItem) item;
			if (msgItem.getMessage() instanceof StayAliveMessage)
				return;
		}
		
		// log the rest
		String logentry = "SEND " + item;
		if (channel instanceof DatagramChannel) {
			if (item.getTargetAddress() != null)
				logentry += ( " to " + item.getTargetAddress().toString());
			else logentry += ( " to " ) + ((DatagramChannel) channel).socket().getRemoteSocketAddress();
		} else if (channel instanceof SocketChannel) {
			logentry += (" to " + ((SocketChannel) channel).socket().getRemoteSocketAddress());
		}
		Logger.log(logentry);
	}

	private void refreshBandwidthLimits(SelectableChannel channel, int written) {
		// delay next write according to maxBytesPerSec
		LimitBandwidthInfo info = bandwidthLimits.get(channel);
		if (info != null && info.getMaxOutputPerSec() != -1) {
			// write delay in milliseconds [factor 1000]
			int writeDelay = written * 1000 / info.getMaxOutputPerSec();
			eventReader.delayNextWrite(channel, writeDelay);
		}
	}

	private boolean isSendAllowed(int length) {
		// TODO connect with bandwidth manager
		return true;
	}

	/**
	 * Returns the size of the next message given the bytebuffer. It assumes that the bytebuffer has been
	 * compacted since the last read, meaning that the position points to the current point where we WRITE
	 * data.
	 * 
	 * @param bb bytebuffer
	 * @return size of next message (first 4 bytes of bytebuffer)
	 */
	private int getMessageSize(ByteBuffer bb) {
		// does buffer already contain a message size (int, 4 bytes)
		if (bb.position() < 4)
			return -1;
		
		// get int
		int size = bb.getInt(0);
		if (size <= 0 || size > MAX_MESSAGE_SIZE) {
			return -1;
		}
		return size;
	}

	/**
	 * Sets the write-interested flag corresponding to the parameter.
	 * 
	 * @param channel channel
	 * @param writeInterested true when we are write-interested, false otherwise
	 */
	private void setWriteInterested(SelectableChannel channel, boolean writeInterested) {
		int oldops = eventReader.getRegisteredOps(channel);
		int newops = writeInterested ? (oldops | SelectionKey.OP_WRITE) : (oldops & ~(SelectionKey.OP_WRITE));
		if (oldops != newops)
			eventReader.setRegisteredOps(channel, newops);
	}

	public void limitIncomingTraffic(SelectableChannel channel, int bytesPerSec) {
		// get/add LimitBandwidthInfo object
		LimitBandwidthInfo bi = bandwidthLimits.get(channel);
		if (bi == null) {
			bi = new LimitBandwidthInfo();
			bandwidthLimits.put(channel, bi);
		}
		
		// set limit
		bi.setMaxInputPerSec(bytesPerSec);
	}

	public void limitOutgoingTraffic(SelectableChannel channel, int bytesPerSec) {
		// get/add LimitBandwidthInfo object
		LimitBandwidthInfo bi = bandwidthLimits.get(channel);
		if (bi == null) {
			bi = new LimitBandwidthInfo();
			bandwidthLimits.put(channel, bi);
		}
		
		// set limit
		bi.setMaxOutputPerSec(bytesPerSec);
	}

	/**
	 * Registers a raw reader for the given channel. Instead of trying to read messages, we now just
	 * pass the data to that reader. Invoking this method with <tt>rawReader == null</tt> returns
	 * to the message-based mode.
	 * 
	 * @param channel channel
	 * @param rawReader rawReader which get the received data
	 */
	public void registerRawReader(SelectableChannel channel, IRawReader rawReader) {
		if (rawReader == null)
			rawReaders.remove(channel);
		else rawReaders.put(channel, rawReader);
	}

}
